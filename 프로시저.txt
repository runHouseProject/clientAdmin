-- Supabase AI is experimental and may produce incorrect answers
-- Always verify the output before executing

 ㅡ<프로시저저장>
get_user_attendance()

SELECT
  u."_id" AS KEY,
  u.name AS NAME,
  u."birthYear"::INT AS birthYear,
  COUNT(m._id) AS attendance,
  COUNT(
    DISTINCT CASE
      WHEN m.founder = TRUE THEN m._id
    END
  ) AS meetings,
  TO_CHAR(u.created_at, 'YYYY-MM-DD') AS joinDate
FROM
  public."user" u
  LEFT JOIN public.meeting m ON u."accountId" = m."accountId"
GROUP BY
  u."_id",
  u.name,
  u."birthYear",
  u.created_at





<get_meeting_count_by_date_range>================================================================
<월별 모임 개설 건수 파악  날짜 범위에서>
CALL get_meeting_count_by_date_range(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_meeting_count_by_date_range(
    p_start_year INTEGER,
    p_start_month INTEGER,
    p_end_year INTEGER,
    p_end_month INTEGER
)
RETURNS TABLE(year INTEGER, month INTEGER, founder_count INTEGER)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    WITH date_series AS (
        SELECT 
            (date_trunc('month', generate_series(
                MAKE_TIMESTAMP(p_start_year, p_start_month, 1, 0, 0, 0),
                MAKE_TIMESTAMP(p_end_year, p_end_month, 1, 0, 0, 0),
                '1 month'::interval
            )))::timestamp AS month_start
    )
    SELECT
        EXTRACT(YEAR FROM ds.month_start)::INTEGER AS year,
        EXTRACT(MONTH FROM ds.month_start)::INTEGER AS month,
        COALESCE(COUNT(m.meeting_date), 0)::INTEGER AS founder_count
    FROM
        date_series ds
        LEFT JOIN meeting m ON EXTRACT(YEAR FROM m.meeting_date::TIMESTAMP WITHOUT TIME ZONE) = EXTRACT(YEAR FROM ds.month_start)
        AND EXTRACT(MONTH FROM m.meeting_date::TIMESTAMP WITHOUT TIME ZONE) = EXTRACT(MONTH FROM ds.month_start)
        AND m.founder = TRUE
        AND (delete IS NULL OR delete = FALSE)
    GROUP BY
        ds.month_start
    ORDER BY
        ds.month_start;
END;
$$;




<get_meeting_count_by_date_range>================================================================
<월별 유저 수 활동중인>
CALL get_user_count_for_period(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION user_count_for_period(
  start_year INT, 
  start_month INT, 
  end_year INT, 
  end_month INT
)
RETURNS TABLE (
  YEAR INT,
  MONTH INT,
  user_count INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    EXTRACT(YEAR FROM created_at) AS YEAR,
    EXTRACT(MONTH FROM created_at) AS MONTH,
    COUNT(*) AS user_count
  FROM
    public.user
  WHERE
    created_at >= MAKE_TIMESTAMP(start_year, start_month, 1, 0, 0, 0)
    AND created_at < MAKE_TIMESTAMP(end_year, end_month, 1, 0, 0, 0) + INTERVAL '1 MONTH'
    AND activation = TRUE
  GROUP BY
    EXTRACT(YEAR FROM created_at),
    EXTRACT(MONTH FROM created_at)
  ORDER BY
    YEAR DESC,
    MONTH DESC;
END;
$$ LANGUAGE plpgsql;

<get_meeting_count_for_period>================================================================
<월별 모임 참여자 수 (중복참여자 상관없이) 단, 삭제된건 제외>
CALL get_meeting_count_for_period(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_meeting_count_for_period(
  start_year INT, 
  start_month INT, 
  end_year INT, 
  end_month INT
)
RETURNS TABLE (
  YEAR INT,
  MONTH INT,
  meeting_count INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    EXTRACT(YEAR FROM meeting_date)::INT AS YEAR,
    EXTRACT(MONTH FROM meeting_date)::INT AS MONTH,
    COUNT(*)::INT AS meeting_count
  FROM
    public.meeting
  WHERE
    meeting_date >= MAKE_TIMESTAMP(start_year, start_month, 1, 0, 0, 0)
    AND meeting_date < MAKE_TIMESTAMP(end_year, end_month, 1, 0, 0, 0) + INTERVAL '1 MONTH'
    AND (delete IS NULL OR delete = FALSE)
  GROUP BY
    EXTRACT(YEAR FROM meeting_date)::INT,
    EXTRACT(MONTH FROM meeting_date)::INT
  ORDER BY
    YEAR DESC,
    MONTH ASC;
END;
$$ LANGUAGE plpgsql;


<get_distinct_user_for_period_by_month>================================================================
<월별 참여 한번이라도 한 인원 파악>
CALL get_distinct_user_for_period_by_month(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_distinct_user_for_period_by_month(
  start_year INT, 
  start_month INT, 
  end_year INT, 
  end_month INT
)
RETURNS TABLE (
  year INT,
  month INT,
  distinct_account_count INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    EXTRACT(YEAR FROM meeting_date)::INT AS year,
    EXTRACT(MONTH FROM meeting_date)::INT AS month,
    COUNT(DISTINCT "accountId")::INT AS distinct_account_count
  FROM
    public.meeting
  WHERE
    meeting_date >= MAKE_TIMESTAMP(start_year, start_month, 1, 0, 0, 0)
    AND meeting_date < MAKE_TIMESTAMP(end_year, end_month, 1, 0, 0, 0) + INTERVAL '1 MONTH'
    AND (delete IS NULL OR delete = FALSE)
  GROUP BY
    EXTRACT(YEAR FROM meeting_date)::INT,
    EXTRACT(MONTH FROM meeting_date)::INT
  ORDER BY
    year ASC,
    month ASC;
END;
$$ LANGUAGE plpgsql;


<get_distinct_founder_count_by_period>================================================================
<월별기준 개설자의 수(사람자체의 숫자)>
select * from get_distinct_founder_count_by_period(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_distinct_founder_count_by_period (
  start_year INTEGER,
  start_month INTEGER,
  end_year INTEGER,
  end_month INTEGER
) 
RETURNS TABLE (year INTEGER, month INTEGER, founder_count BIGINT) 
AS $$
BEGIN
  RETURN QUERY
  SELECT
    EXTRACT(YEAR FROM meeting.meeting_date)::INT AS year,
    EXTRACT(MONTH FROM meeting.meeting_date)::INT AS month,
    COUNT(DISTINCT meeting."accountId")::BIGINT AS founder_count
  FROM
    public.meeting
  WHERE
    (EXTRACT(YEAR FROM meeting.meeting_date)::INT * 100 + EXTRACT(MONTH FROM meeting.meeting_date)::INT)
    BETWEEN (start_year * 100 + start_month) AND (end_year * 100 + end_month)
    AND meeting.founder = true
    AND meeting.delete IS NULL
  GROUP BY
    EXTRACT(YEAR FROM meeting.meeting_date)::INT,
    EXTRACT(MONTH FROM meeting.meeting_date)::INT
  ORDER BY
    year ASC,
    month ASC;
END;
$$ LANGUAGE plpgsql;




<get_location_meeting_percentage_for_period>================================================================
<월별기준 장소별 참여 횟수 및 트랜드>
select * from  get_location_meeting_percentage_for_period(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_location_meeting_percentage_for_period(
  start_year INT, 
  start_month INT, 
  end_year INT, 
  end_month INT
)
RETURNS TABLE (
  location_name TEXT,
  month INT,
  meeting_count INT,
  total_meeting_count INT,
  percentage NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  WITH
    monthly_meeting_counts AS (
      SELECT
        l.name AS location_name,
        EXTRACT(MONTH FROM m.meeting_date)::INT AS month,
        COUNT(*)::INT AS meeting_count
      FROM
        public.meeting m
        INNER JOIN public.location l ON m.location = l.code
      WHERE
        m.meeting_date >= MAKE_TIMESTAMP(start_year, start_month, 1, 0, 0, 0)
        AND m.meeting_date < MAKE_TIMESTAMP(end_year, end_month, 1, 0, 0, 0) + INTERVAL '1 MONTH'
        AND (m.delete IS NULL OR m.delete = FALSE)
      GROUP BY
        l.name,
        EXTRACT(MONTH FROM m.meeting_date)
    ),
    total_meeting_counts AS (
      SELECT
        EXTRACT(MONTH FROM meeting_date)::INT AS month,
        COUNT(*)::INT AS total_meeting_count
      FROM
        public.meeting
      WHERE
        meeting_date >= MAKE_TIMESTAMP(start_year, start_month, 1, 0, 0, 0)
        AND meeting_date < MAKE_TIMESTAMP(end_year, end_month, 1, 0, 0, 0) + INTERVAL '1 MONTH'
        AND (delete IS NULL OR delete = FALSE)
      GROUP BY
        EXTRACT(MONTH FROM meeting_date)
    )
  SELECT
    mmc.location_name,
    mmc.month,
    mmc.meeting_count,
    tmc.total_meeting_count,
    ROUND((mmc.meeting_count::NUMERIC / tmc.total_meeting_count) * 100, 2) AS percentage
  FROM
    monthly_meeting_counts mmc
    JOIN total_meeting_counts tmc ON mmc.month = tmc.month
  ORDER BY
    mmc.month,
    mmc.location_name;
END;
$$ LANGUAGE plpgsql;




<get_age_group_meeting_percentage_for_period>================================================================
<월별기준 나이대별 참여율>
CALL get_meeting_count_for_period(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_age_group_meeting_percentage_for_period(
  start_year INT, 
  start_month INT, 
  end_year INT, 
  end_month INT
)
RETURNS TABLE (
  age INT,
  month INT,
  meeting_count INT,
  total_meeting_count INT,
  participation_rate NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  WITH age_groups AS (
    SELECT
      CASE 
        WHEN LEFT("birthYear", 1) = '9' OR LEFT("birthYear", 1) = '8' THEN 
          EXTRACT(YEAR FROM CURRENT_DATE) - (1900 + CAST("birthYear" AS INTEGER)) + 1
        ELSE 
          EXTRACT(YEAR FROM CURRENT_DATE) - (2000 + CAST("birthYear" AS INTEGER)) + 1
      END AS age,
      EXTRACT(MONTH FROM meeting_date) AS month,
      COUNT(*) AS meeting_count
    FROM
      public.meeting
    WHERE
      "birthYear" IS NOT NULL
      AND meeting_date >= MAKE_TIMESTAMP(start_year, start_month, 1, 0, 0, 0)
      AND meeting_date < MAKE_TIMESTAMP(end_year, end_month, 1, 0, 0, 0) + INTERVAL '1 MONTH'
    GROUP BY
      age,
      EXTRACT(MONTH FROM meeting_date)
  )
  SELECT
    age,
    month,
    meeting_count,
    SUM(meeting_count) OVER (
      PARTITION BY month
    ) AS total_meeting_count,
    ROUND(
      (
        meeting_count::NUMERIC / SUM(meeting_count) OVER (
          PARTITION BY month
        )
      ) * 100,
      2
    ) AS participation_rate
  FROM
    age_groups
  ORDER BY
    age,
    month;
END;
$$ LANGUAGE plpgsql;






<get_participation_user_counts_week_detail_by_period>================================================================
<월별 기간 입력시 주마다(7일단위)의 참여 크루원 결과>
SELECT * FROM get_participation_user_counts_week_detail_by_period(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_participation_user_counts_week_detail_by_period(
    start_year INT, 
    start_month INT, 
    end_year INT, 
    end_month INT
)
RETURNS TABLE (
    year INTEGER,
    month INTEGER,
    period TEXT,
    participation_user_count INTEGER,
    period_start_date DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        EXTRACT(YEAR FROM meeting.meeting_date)::INT AS year,
        EXTRACT(MONTH FROM meeting.meeting_date)::INT AS month,
        CASE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 1 AND 7 THEN '1-7'
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 8 AND 14 THEN '8-14'
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 15 AND 21 THEN '15-21'
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 22 AND 28 THEN '22-28'
            ELSE '29-month_end'
        END AS period,
        COUNT(meeting."accountId")::INT AS participation_user_count,
        CASE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 1 AND 7 THEN (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '0 day')::DATE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 8 AND 14 THEN (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '7 days')::DATE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 15 AND 21 THEN (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '14 days')::DATE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 22 AND 28 THEN (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '21 days')::DATE
            ELSE (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '28 days')::DATE
        END AS period_start_date
    FROM
        public.meeting
    WHERE
        EXTRACT(YEAR FROM meeting.meeting_date)::INT * 100 + EXTRACT(MONTH FROM meeting.meeting_date)::INT
        BETWEEN start_year * 100 + start_month AND end_year * 100 + end_month
        AND (delete IS NULL OR delete = FALSE)
    GROUP BY
        EXTRACT(YEAR FROM meeting.meeting_date)::INT,
        EXTRACT(MONTH FROM meeting.meeting_date)::INT,
        CASE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 1 AND 7 THEN '1-7'
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 8 AND 14 THEN '8-14'
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 15 AND 21 THEN '15-21'
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 22 AND 28 THEN '22-28'
            ELSE '29-month_end'
        END,
        CASE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 1 AND 7 THEN (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '0 day')::DATE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 8 AND 14 THEN (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '7 days')::DATE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 15 AND 21 THEN (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '14 days')::DATE
            WHEN DATE_PART('day', meeting.meeting_date) BETWEEN 22 AND 28 THEN (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '21 days')::DATE
            ELSE (DATE_TRUNC('month', meeting.meeting_date) + INTERVAL '28 days')::DATE
        END
    ORDER BY
        year, month, period_start_date;
END;
$$ LANGUAGE plpgsql;





<get_monthly_user_count_by_month>================================================================
<월별 기간 입력시 월별 누적 유적 수 결과>
CALL get_monthly_user_count_by_month(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_monthly_user_count_by_month(start_year INT, start_month INT, end_year INT, end_month INT)
RETURNS TABLE(year INT, month INT, total_members INT) AS $$
BEGIN
  RETURN QUERY WITH user_counts AS (
      SELECT
          EXTRACT(YEAR FROM created_at) AS user_year,
          EXTRACT(MONTH FROM created_at) AS user_month,
          COUNT(*) AS monthly_count
      FROM
          public."user"
      GROUP BY
          EXTRACT(YEAR FROM created_at),
          EXTRACT(MONTH FROM created_at)
  ),
  cumulative_counts AS (
      SELECT
          user_year,
          user_month,
          SUM(monthly_count) OVER (ORDER BY user_year, user_month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_total_members
      FROM
          user_counts
  )
  SELECT
      user_year::INT AS year,
      user_month::INT AS month,
      cumulative_total_members::INT AS total_members
  FROM
      cumulative_counts
  WHERE
      (user_year * 100 + user_month) BETWEEN (start_year * 100 + start_month) AND (end_year * 100 + end_month)
  ORDER BY
      user_year,
      user_month;
END;
$$ LANGUAGE plpgsql;




<get_inactive_users>================================================================
<미참여 유저및 참역일 이 오래되신분>
select * from get_inactive_users(2023, 1, 2024, 9);
================================================================
CREATE OR REPLACE FUNCTION get_inactive_users()
RETURNS TABLE (
  name TEXT,
  birthYear TEXT,
  lastMeeting TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    subquery.name,
    subquery."birthYear",
    COALESCE(subquery.lastMeeting::text, '미참여') AS lastMeeting
  FROM (
    SELECT
      u.name,
      u."birthYear",
      MAX(m."meeting_date") AS lastMeeting
    FROM
      public."user" u
      LEFT JOIN public.meeting m ON u."accountId" = m."accountId"
    GROUP BY
      u.name,
      u."birthYear"
  ) AS subquery
  ORDER BY
    lastMeeting ASC;
END;
$$;


select * from get_inactive_users();
